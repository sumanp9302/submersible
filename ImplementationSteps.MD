‚úÖ What you‚Äôve already done
[1] Basic model + movement (3D)
‚Ä¢	Created Direction enum: NORTH, SOUTH, EAST, WEST.
‚Ä¢	Created Probe with fields: x, y, z, direction.
‚Ä¢	Implemented:
o	moveForward()
o	moveBackward()
o	turnLeft()
o	turnRight()
o	moveUp()
o	moveDown()
‚Ä¢	Wrote tests:
o	shouldInitializeProbeWithGivenCoordinatesAndDirection
o	Parameterized tests for:
ÔÇß	shouldMoveForward(...)
ÔÇß	shouldMoveBackward(...)
o	Parameterized tests for:
ÔÇß	shouldTurnLeft(...)
ÔÇß	shouldTurnRight(...)
o	shouldMoveUpAndDown
üëâ You now have a working, unit-tested 3D probe that moves in free space.
________________________________________

‚è≠Ô∏è Your next immediate step (when you resume)
[2] Introduce a Grid and enforce boundaries (‚ÄúStay on the grid‚Äù)
Right now, your probe can wander off to negative coordinates or very large numbers.
Goal of this step
‚Ä¢	Create a Grid concept.
‚Ä¢	Make sure the probe never leaves the grid.
‚Ä¢	If a move would go out of bounds, that move is ignored, and the probe stays where it is.
What to do (TDD way)
1.	Write tests first (new test class, no implementation yet):
o	GridTest ‚Äì to check:
ÔÇß	Valid positions are inside bounds.
ÔÇß	Invalid positions are outside bounds.
o	ProbeGridMovementTest ‚Äì to check:
ÔÇß	Probe placed at edge cannot move further in that direction.
ÔÇß	Position remains unchanged when a move would go out of bounds.
2.	Then implement:
o	A Grid class (e.g. with width, height).
o	Update Probe constructor to take a Grid.
o	Update moveForward / moveBackward to:
ÔÇß	Calculate candidate position.
ÔÇß	Check with grid if it‚Äôs valid.
ÔÇß	Only update coordinates if inside the grid.
üëâ When you come back later, start exactly from: "Create tests for Grid and boundary behavior".
________________________________________
üîú Roadmap of later steps (in recommended order)
After step [2], you can follow this sequence:
________________________________________


[3] Add obstacles in the grid (‚ÄúAvoid obstacles‚Äù)
Goal
The probe should not move into coordinates that contain obstacles.
TDD steps
‚Ä¢	Add tests:
o	When next position is an obstacle ‚Üí probe stays in current position.
o	Movement in other directions still works.
‚Ä¢	Implement:
o	Grid holds a set of obstacle positions.
o	Probe checks grid.isObstacle(candidatePosition) before moving, and ignores the move if true.
________________________________________
[4] Track visited coordinates (‚ÄúPrint summary of coordinates visited‚Äù)
Goal
Keep a history of all coordinates visited, including the starting point.
TDD steps
‚Ä¢	Tests:
o	After a sequence of valid moves, visited list contains start + each successfully moved position.
o	Moves blocked by boundary or obstacle should not add a new entry.
‚Ä¢	Implementation:
o	Add List<Position> visited (or similar) inside Probe.
o	Add start position in the constructor.
o	On every successful move, append the new position.
(Printing/summarizing can be done later, at API layer or as a simple method like getVisited().)
________________________________________
[5] Execute command sequences (F/B/L/R)
Goal
Instead of calling moveForward() etc. one by one, send a string like "FFRBL" and interpret it.
TDD steps
‚Ä¢	Tests:
o	Define a few sequences and expected final position + direction.
o	Include a mix of F, B, L, R (and possibly edge cases like empty string).
‚Ä¢	Implementation:
o	Add execute(String commands) to Probe.
o	Loop over characters and call the appropriate method.
o	For invalid characters: either throw IllegalArgumentException or skip (decide and test for it).
________________________________________
[6] Refactor direction logic into Direction enum (optional but clean)
Goal
Make the code cleaner by moving ‚Äúturn left/right‚Äù logic to Direction.
TDD steps
‚Ä¢	Add tests in a DirectionTest class:
o	Turning left from each direction gives correct result.
o	Turning right from each direction gives correct result.
‚Ä¢	Implementation:
o	Add turnLeft() and turnRight() methods in Direction.
o	Update Probe.turnLeft() and Probe.turnRight() to use direction = direction.turnLeft() etc.
________________________________________
[7] Decide on 2D vs 3D model alignment with problem statement
Your kata statement mentions only x/y grid, no z.
You currently have z and moveUp/moveDown.
You have two options:
‚Ä¢	Option A ‚Äì Stick with 3D: keep z and say your solution is an extended version.
‚Ä¢	Option B ‚Äì Move to 2D for the ‚Äúofficial‚Äù kata:
o	Ignore z in the main kata.
o	Keep 3D version in a separate branch or package as a bonus.
Whichever you decide, note it in a README or comment so future you aren‚Äôt confused.
________________________________________



[8] REST API ‚Äì wrap the domain
After the core domain is solid and well tested, start on REST:
Goal
Expose an endpoint that:
‚Ä¢	Accepts grid size, obstacles, start position, start direction, and command string
‚Ä¢	Returns final position and path (visited coordinates)
TDD steps
‚Ä¢	Define request/response DTOs.
‚Ä¢	Write Spring MVC tests (using @WebMvcTest or similar) to:
o	Call the endpoint with JSON.
o	Assert on response body and status.
‚Ä¢	Implement:
o	ProbeService to map DTO ‚Üí domain objects ‚Üí response DTO.
o	ProbeController with a POST /probe/commands endpoint.
________________________________________
[9] Edge cases & polish
Once everything works:
‚Ä¢	Input validation tests:
o	Invalid grid size (0, negative).
o	Start position outside grid.
o	Start position on obstacle.
o	Empty / null command string.
‚Ä¢	Behavior tests:
o	Only turns (no movement).
o	Commands that hit boundaries and obstacles in sequence.
‚Ä¢	Logging / error messages:
o	Return meaningful error messages from the API.
________________________________________
[10] Git history best practices
When you work through this list next time, try to structure commits like:
‚Ä¢	feat: add grid boundaries to probe movement
‚Ä¢	test: add obstacle avoidance tests
‚Ä¢	feat: implement obstacles in grid
‚Ä¢	refactor: move direction turning logic to enum
‚Ä¢	feat: add execute command sequence to probe
‚Ä¢	feat: expose probe control REST endpoint
Small, focused commits will make your learning journey very clear.

